---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Stack Map" description="Interactive engineering stack and experience map">
  <section class="hero stack-hero">
    <h1>Engineering Stack Map</h1>
    <p>
      A live map of platform capabilities, architecture dependencies, and production outcomes across backend, AI, data, and agent systems.
    </p>
  </section>

  <section class="section">
    <h2>Capability Matrix</h2>
    <div class="panel">
      <div class="stack-controls">
        <div id="bubble-filters" class="chip-row"></div>
        <label class="search-wrap" for="skill-search">
          <span>Search</span>
          <input id="skill-search" type="search" placeholder="python, kafka, fastapi..." autocomplete="off" />
        </label>
      </div>
      <div id="bubble-cloud" class="bubble-cloud"></div>
    </div>
  </section>

  <section class="section">
    <h2>Knowledge Graph</h2>
    <div class="panel graph-panel">
      <div>
        <div id="graph-filters" class="chip-row"></div>
        <svg id="stack-graph" viewBox="0 0 980 560" role="img" aria-label="Knowledge graph of projects, technologies, and outcomes"></svg>
      </div>
      <div class="graph-side">
        <div id="graph-legend" class="graph-legend"></div>
        <aside class="graph-detail">
          <h3 id="graph-title">Select a Node</h3>
          <p id="graph-detail">Select a node to inspect what it does, where it is used, and how it ties to impact.</p>
        </aside>
      </div>
    </div>
  </section>

  <section class="section">
    <h2>Timeline Heatmap</h2>
    <div class="panel">
      <div id="timeline-wrap" class="timeline-wrap"></div>
    </div>
  </section>
</BaseLayout>

<script is:inline>
  const CATEGORY_COLORS = {
    backend: '#63b6ff',
    ai: '#a78bfa',
    data: '#2dd4bf',
    infra: '#f59e0b',
    agent: '#f472b6'
  };

  const TYPE_LABELS = {
    all: 'All Nodes',
    project: 'Projects',
    tech: 'Tech',
    impact: 'Impact'
  };

  async function loadStackMap() {
    const res = await fetch('/data/stack-map.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('Failed to load stack map data.');
    return res.json();
  }

  function escapeHtml(value) {
    return value
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function renderBubbles(data) {
    const filterRoot = document.getElementById('bubble-filters');
    const cloud = document.getElementById('bubble-cloud');
    const searchInput = document.getElementById('skill-search');
    if (!filterRoot || !cloud || !searchInput) return;

    let active = 'all';
    let term = '';
    const categories = [{ id: 'all', label: 'All' }, ...data.categories];

    function paint() {
      const results = data.skills.filter((skill) => {
        if (active !== 'all' && skill.category !== active) return false;
        if (!term) return true;
        const hay = `${skill.name} ${skill.summary}`.toLowerCase();
        return hay.includes(term);
      });

      cloud.innerHTML = '';
      results
        .sort((a, b) => b.level - a.level)
        .forEach((skill) => {
          const el = document.createElement('article');
          el.className = 'stack-bubble';
          el.style.setProperty('--bubble-color', CATEGORY_COLORS[skill.category] || '#60a5fa');
          el.innerHTML =
            `<header><strong>${escapeHtml(skill.name)}</strong><span>Level ${skill.level}/10</span></header>` +
            `<p>${escapeHtml(skill.summary)}</p>` +
            `<footer>Since ${skill.since}</footer>`;
          cloud.appendChild(el);
        });

      if (!results.length) {
        cloud.innerHTML = '<p class="empty">No skills match that filter.</p>';
      }
    }

    categories.forEach((cat) => {
      const count = cat.id === 'all' ? data.skills.length : data.skills.filter((s) => s.category === cat.id).length;
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'stack-chip' + (cat.id === active ? ' active' : '');
      btn.textContent = `${cat.label} (${count})`;
      btn.addEventListener('click', () => {
        active = cat.id;
        Array.from(filterRoot.querySelectorAll('.stack-chip')).forEach((node) => node.classList.remove('active'));
        btn.classList.add('active');
        paint();
      });
      filterRoot.appendChild(btn);
    });

    searchInput.addEventListener('input', () => {
      term = searchInput.value.trim().toLowerCase();
      paint();
    });

    paint();
  }

  function layoutGraph(nodes, links) {
    const W = 980, H = 560, PAD = 62;
    const anchors = {
      backend: [210, 155],
      ai:      [770, 155],
      data:    [210, 420],
      infra:   [770, 420],
      agent:   [490, 288]
    };

    // Deterministic seed positions (golden-angle spiral per group)
    const counts = { backend: 0, ai: 0, data: 0, infra: 0, agent: 0 };
    nodes.forEach((node) => {
      const [cx, cy] = anchors[node.group] || [490, 288];
      const idx = counts[node.group] ?? 0;
      const angle = idx * 2.39996; // golden ratio
      const r = 28 + (idx % 4) * 22;
      node.x = Math.max(PAD, Math.min(W - PAD, cx + Math.cos(angle) * r));
      node.y = Math.max(PAD, Math.min(H - PAD, cy + Math.sin(angle) * r));
      node.vx = 0;
      node.vy = 0;
      counts[node.group] = idx + 1;
    });

    const byId = new Map(nodes.map((n) => [n.id, n]));
    const REPULSION  = 3000;
    const SPRING_LEN = 108;
    const SPRING_K   = 0.044;
    const GRAVITY    = 0.022;
    const DAMPING    = 0.78;
    const ITERS      = 280;

    for (let iter = 0; iter < ITERS; iter++) {
      const alpha = 1 - iter / ITERS;

      // Node-pair repulsion
      for (let a = 0; a < nodes.length; a++) {
        for (let b = a + 1; b < nodes.length; b++) {
          const na = nodes[a], nb = nodes[b];
          const dx = nb.x - na.x || 0.01;
          const dy = nb.y - na.y || 0.01;
          const dist2 = dx * dx + dy * dy + 0.01;
          const dist  = Math.sqrt(dist2);
          const f  = (REPULSION / dist2) * alpha;
          const fx = (f * dx) / dist;
          const fy = (f * dy) / dist;
          na.vx -= fx; na.vy -= fy;
          nb.vx += fx; nb.vy += fy;
        }
      }

      // Spring attraction along edges
      links.forEach((link) => {
        const a = byId.get(link.source);
        const b = byId.get(link.target);
        if (!a || !b) return;
        const dx   = b.x - a.x;
        const dy   = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const f    = SPRING_K * (dist - SPRING_LEN);
        const fx   = (f * dx) / dist;
        const fy   = (f * dy) / dist;
        a.vx += fx; a.vy += fy;
        b.vx -= fx; b.vy -= fy;
      });

      // Weak gravity toward group anchor
      nodes.forEach((node) => {
        const [cx, cy] = anchors[node.group] || [490, 288];
        node.vx += GRAVITY * (cx - node.x);
        node.vy += GRAVITY * (cy - node.y);
      });

      // Integrate + clamp
      nodes.forEach((node) => {
        node.vx *= DAMPING;
        node.vy *= DAMPING;
        node.x = Math.max(PAD, Math.min(W - PAD, node.x + node.vx));
        node.y = Math.max(PAD, Math.min(H - PAD, node.y + node.vy));
      });
    }
  }

  function renderGraph(data) {
    const svg = document.getElementById('stack-graph');
    const title = document.getElementById('graph-title');
    const detail = document.getElementById('graph-detail');
    const legend = document.getElementById('graph-legend');
    const filterRoot = document.getElementById('graph-filters');
    if (!svg || !title || !detail || !legend || !filterRoot) return;

    const nodes = data.graph.nodes.map((n) => ({ ...n }));
    const links = data.graph.links.map((l, idx) => ({ ...l, id: `e${idx}` }));
    const byId = new Map(nodes.map((n) => [n.id, n]));
    layoutGraph(nodes, links);

    let typeFilter = 'all';
    let activeNodeId = null;

    const ns = 'http://www.w3.org/2000/svg';
    const edgeLayer = document.createElementNS(ns, 'g');
    const nodeLayer = document.createElementNS(ns, 'g');
    svg.innerHTML = '';
    svg.append(edgeLayer, nodeLayer);

    data.categories.forEach((cat) => {
      const chip = document.createElement('span');
      chip.className = 'graph-legend-chip';
      chip.innerHTML = `<i style="background:${cat.color}"></i>${cat.label}`;
      legend.appendChild(chip);
    });

    Object.entries(TYPE_LABELS).forEach(([type, label]) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'stack-chip' + (type === typeFilter ? ' active' : '');
      btn.textContent = label;
      btn.addEventListener('click', () => {
        typeFilter = type;
        Array.from(filterRoot.querySelectorAll('.stack-chip')).forEach((node) => node.classList.remove('active'));
        btn.classList.add('active');
        paintVisibility();
      });
      filterRoot.appendChild(btn);
    });

    const edgeEls = new Map();
    links.forEach((link) => {
      const a = byId.get(link.source);
      const b = byId.get(link.target);
      if (!a || !b) return;
      const line = document.createElementNS(ns, 'line');
      line.setAttribute('x1', String(a.x));
      line.setAttribute('y1', String(a.y));
      line.setAttribute('x2', String(b.x));
      line.setAttribute('y2', String(b.y));
      line.setAttribute('class', 'stack-graph-edge');
      edgeLayer.appendChild(line);
      edgeEls.set(link.id, { line, link });
    });

    const nodeEls = new Map();
    nodes.forEach((node) => {
      const g = document.createElementNS(ns, 'g');
      g.setAttribute('class', 'stack-graph-node');
      g.setAttribute('transform', `translate(${node.x},${node.y})`);
      g.setAttribute('data-type', node.type);
      g.setAttribute('tabindex', '0');

      const circle = document.createElementNS(ns, 'circle');
      circle.setAttribute('r', node.type === 'project' ? '18' : node.type === 'impact' ? '14' : '11');
      circle.setAttribute('fill', CATEGORY_COLORS[node.group] || '#60a5fa');
      circle.setAttribute('stroke', '#07111f');
      circle.setAttribute('stroke-width', '2.2');

      const labelOffset = node.type === 'project' ? '32' : node.type === 'impact' ? '28' : '22';
      const label = document.createElementNS(ns, 'text');
      label.setAttribute('y', labelOffset);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('class', 'stack-graph-label');
      if (node.type === 'tech') label.setAttribute('font-size', '10');
      label.textContent = node.label;
      g.append(circle, label);

      function activate() {
        activeNodeId = node.id;
        title.textContent = node.label;
        detail.textContent = node.detail;
        paintActiveState();
      }

      g.addEventListener('click', activate);
      g.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          activate();
        }
      });

      g.addEventListener('mouseenter', () => {
        title.textContent = node.label;
        detail.textContent = node.detail;
      });

      nodeLayer.appendChild(g);
      nodeEls.set(node.id, { node, g });
    });

    function isNodeVisible(node) {
      return typeFilter === 'all' || node.type === typeFilter;
    }

    function paintVisibility() {
      nodeEls.forEach(({ node, g }) => {
        g.classList.toggle('hidden', !isNodeVisible(node));
      });

      edgeEls.forEach(({ line, link }) => {
        const a = byId.get(link.source);
        const b = byId.get(link.target);
        const visible = a && b && isNodeVisible(a) && isNodeVisible(b);
        line.classList.toggle('hidden', !visible);
      });

      paintActiveState();
    }

    function paintActiveState() {
      nodeEls.forEach(({ g }) => g.classList.remove('active', 'connected', 'dim'));
      edgeEls.forEach(({ line }) => line.classList.remove('active', 'dim'));

      if (!activeNodeId || !nodeEls.has(activeNodeId)) return;

      const connected = new Set([activeNodeId]);
      edgeEls.forEach(({ link }) => {
        if (link.source === activeNodeId) connected.add(link.target);
        if (link.target === activeNodeId) connected.add(link.source);
      });

      nodeEls.forEach(({ node, g }) => {
        if (!isNodeVisible(node)) return;
        if (node.id === activeNodeId) g.classList.add('active');
        else if (connected.has(node.id)) g.classList.add('connected');
        else g.classList.add('dim');
      });

      edgeEls.forEach(({ line, link }) => {
        const a = byId.get(link.source);
        const b = byId.get(link.target);
        if (!(a && b && isNodeVisible(a) && isNodeVisible(b))) return;
        if (link.source === activeNodeId || link.target === activeNodeId) line.classList.add('active');
        else line.classList.add('dim');
      });
    }

    paintVisibility();
  }

  function renderTimeline(data) {
    const root = document.getElementById('timeline-wrap');
    if (!root) return;
    const years = data.timeline.years;

    const table = document.createElement('table');
    table.className = 'stack-timeline-table';

    const thead = document.createElement('thead');
    const tr = document.createElement('tr');
    tr.innerHTML = `<th>Technology</th>${years.map((year) => `<th>${year}</th>`).join('')}`;
    thead.appendChild(tr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    data.timeline.tracks.forEach((track) => {
      const row = document.createElement('tr');
      const head = document.createElement('td');
      head.textContent = track.label;
      row.appendChild(head);

      years.forEach((year) => {
        const cell = document.createElement('td');
        const on = track.active.includes(year);
        cell.innerHTML = `<span class="stack-heat-cell ${on ? 'on' : 'off'}" title="${track.label} ${year}"></span>`;
        row.appendChild(cell);
      });

      tbody.appendChild(row);
    });

    table.appendChild(tbody);
    root.innerHTML = '';
    root.appendChild(table);
  }

  loadStackMap()
    .then((data) => {
      renderBubbles(data);
      renderGraph(data);
      renderTimeline(data);
    })
    .catch((err) => {
      const root = document.getElementById('timeline-wrap');
      if (root) root.textContent = String(err.message || err);
    });
</script>

<style>
  .stack-hero {
    background:
      radial-gradient(680px 240px at 10% 10%, rgba(99, 182, 255, 0.16), transparent 58%),
      linear-gradient(160deg, rgba(22, 29, 42, 0.9), rgba(12, 18, 28, 0.96));
  }

  .stack-controls {
    display: grid;
    gap: 0.75rem;
  }

  :global(.chip-row) {
    display: flex;
    flex-wrap: wrap;
    gap: 0.55rem;
  }

  .search-wrap {
    display: grid;
    gap: 0.35rem;
    max-width: 320px;
  }

  .search-wrap span {
    font-size: 0.78rem;
    color: var(--text-muted);
    letter-spacing: 0.03em;
    text-transform: uppercase;
  }

  .search-wrap input {
    border: 1px solid #324765;
    background: #0e1828;
    color: var(--text);
    border-radius: 12px;
    padding: 0.55rem 0.7rem;
    outline: none;
    font-size: 0.9rem;
  }

  .search-wrap input:focus {
    border-color: #5c9cff;
    box-shadow: 0 0 0 3px rgba(92, 156, 255, 0.18);
  }

  :global(.stack-chip) {
    border: 1px solid #355075;
    background: linear-gradient(165deg, #1b2a40, #111d2f);
    color: #d7e6ff;
    border-radius: 999px;
    padding: 0.4rem 0.8rem;
    font-size: 0.82rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 140ms ease, border-color 140ms ease;
  }

  :global(.stack-chip:hover) {
    transform: translateY(-1px);
    border-color: #73acff;
  }

  :global(.stack-chip.active) {
    border-color: #73acff;
    background: linear-gradient(165deg, #28446b, #1b2f4a);
    box-shadow: 0 4px 16px rgba(77, 138, 231, 0.3);
  }

  :global(.bubble-cloud) {
    margin-top: 0.9rem;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 0.8rem;
  }

  :global(.stack-bubble) {
    border-radius: 16px;
    border: 1px solid color-mix(in srgb, var(--bubble-color) 58%, #142135 42%);
    background:
      radial-gradient(120px 56px at 88% -8%, color-mix(in srgb, var(--bubble-color) 30%, transparent), transparent 70%),
      linear-gradient(165deg, color-mix(in srgb, var(--bubble-color) 17%, #0f1724 83%), #0b1320);
    padding: 0.84rem;
    display: grid;
    gap: 0.5rem;
    box-shadow: 0 10px 24px rgba(5, 10, 18, 0.34);
  }

  :global(.stack-bubble header) {
    display: flex;
    justify-content: space-between;
    gap: 0.5rem;
    align-items: baseline;
  }

  :global(.stack-bubble strong) {
    color: #f4f8ff;
    font-size: 1rem;
  }

  :global(.stack-bubble header span) {
    color: #9ec2f0;
    font-size: 0.76rem;
    white-space: nowrap;
  }

  :global(.stack-bubble p) {
    margin: 0;
    color: #c0ccdc;
    font-size: 0.89rem;
    line-height: 1.45;
  }

  :global(.stack-bubble footer) {
    color: #8fa4bf;
    font-size: 0.78rem;
  }

  :global(.empty) {
    margin: 0;
    color: var(--text-muted);
  }

  .graph-panel {
    display: grid;
    grid-template-columns: minmax(0, 1.7fr) minmax(0, 1fr);
    gap: 0.95rem;
  }

  #stack-graph {
    margin-top: 0.8rem;
    width: 100%;
    border: 1px solid var(--line);
    border-radius: 14px;
    background:
      radial-gradient(520px 220px at 50% 10%, rgba(97, 170, 255, 0.16), transparent 64%),
      radial-gradient(340px 170px at 15% 88%, rgba(45, 212, 191, 0.09), transparent 62%),
      #0a1220;
    min-height: 560px;
  }

  :global(.stack-graph-edge) {
    stroke: #355172;
    stroke-width: 1.2;
    opacity: 0.55;
    transition: opacity 140ms ease, stroke 140ms ease;
  }

  :global(.stack-graph-node) {
    cursor: pointer;
    transition: opacity 140ms ease;
  }

  :global(.stack-graph-node.hidden),
  :global(.stack-graph-edge.hidden) {
    display: none;
  }

  :global(.stack-graph-node circle) {
    transition: transform 130ms ease, filter 130ms ease, opacity 130ms ease;
  }

  :global(.stack-graph-node:hover circle),
  :global(.stack-graph-node.active circle) {
    filter: brightness(1.14);
    transform: scale(1.14);
  }

  :global(.stack-graph-node.connected circle) {
    opacity: 0.95;
  }

  :global(.stack-graph-node.dim circle) {
    opacity: 0.28;
  }

  :global(.stack-graph-edge.active) {
    stroke: #85b7ff;
    opacity: 0.95;
    stroke-width: 1.8;
  }

  :global(.stack-graph-edge.dim) {
    opacity: 0.12;
  }

  :global(.stack-graph-label) {
    fill: #deebff;
    font-size: 11px;
    font-weight: 600;
    text-anchor: middle;
    paint-order: stroke;
    stroke: #081120;
    stroke-width: 4px;
    stroke-linejoin: round;
    letter-spacing: 0.01em;
    pointer-events: none;
  }

  .graph-side {
    display: grid;
    gap: 0.8rem;
    align-content: start;
  }

  :global(.graph-legend) {
    display: grid;
    gap: 0.48rem;
  }

  :global(.graph-legend-chip) {
    border: 1px solid var(--line);
    border-radius: 10px;
    background: #101a2a;
    color: #d3e0f4;
    padding: 0.44rem 0.55rem;
    font-size: 0.82rem;
    display: flex;
    align-items: center;
    gap: 0.48rem;
  }

  :global(.graph-legend-chip i) {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    box-shadow: 0 0 0 2px rgba(6, 11, 20, 0.8);
  }

  .graph-detail {
    border: 1px solid var(--line);
    border-radius: 14px;
    background: linear-gradient(165deg, #131f31, #0f1828);
    padding: 1rem;
  }

  .graph-detail h3 {
    margin: 0 0 0.5rem;
    font-size: 1.1rem;
  }

  .graph-detail p {
    margin: 0;
    color: #c3cfde;
    line-height: 1.6;
  }

  :global(.timeline-wrap) {
    overflow-x: auto;
  }

  :global(.stack-timeline-table) {
    width: 100%;
    min-width: 860px;
    border-collapse: collapse;
  }

  :global(.stack-timeline-table th),
  :global(.stack-timeline-table td) {
    border-bottom: 1px solid #25344d;
    padding: 0.46rem 0.34rem;
    text-align: center;
    font-size: 0.8rem;
  }

  :global(.stack-timeline-table th:first-child),
  :global(.stack-timeline-table td:first-child) {
    text-align: left;
    width: 220px;
    color: #e4edf9;
    font-weight: 600;
  }

  :global(.stack-heat-cell) {
    width: 14px;
    height: 14px;
    display: inline-block;
    border-radius: 4px;
    border: 1px solid #30445f;
  }

  :global(.stack-heat-cell.on) {
    background: linear-gradient(180deg, #6db2ff, #33669f);
    box-shadow: 0 0 10px rgba(84, 156, 255, 0.25);
  }

  :global(.stack-heat-cell.off) {
    background: #0f1929;
    opacity: 0.56;
  }

  @media (max-width: 1120px) {
    .graph-panel {
      grid-template-columns: 1fr;
    }

    :global(.graph-legend) {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @media (max-width: 740px) {
    :global(.graph-legend) {
      grid-template-columns: 1fr;
    }

    :global(.bubble-cloud) {
      grid-template-columns: 1fr;
    }

    .search-wrap {
      max-width: none;
    }
  }
</style>
